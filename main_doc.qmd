---
title: "main_doc"
format: html
editor: visual
---

# Dependencies

```{r}
library(mice)
library(MASS)
library(furrr)
library(purrr)
```

# Data Simulation

## Defining data simulation function

```{r}
data_generator <- function(sample_size, seed, prop){
  set.seed(seed)
  cor_mat <- matrix(c(1, 0.5, 0.5, 
                      0.5, 1, 0.5, 
                      0.5, 0.5, 1), nrow = 3, ncol = 3)
  
  mean_vec <- c(1, 1, 1)
  
  covariates <- as.data.frame(mvrnorm(sample_size, mu = mean_vec, Sigma = cor_mat))
  covariates$V3 <- ifelse(covariates$V3 > 0, 1, 0)
  
  outcome_variable <- 0 + 
    0.32*covariates$V1 + 
    0.67*covariates$V2 +  
    0.43*covariates$V3 + 
    0.50*covariates$V2*covariates$V3 + # Interaction btwn. V2&V3
    rnorm(100,0,1)
  
  data_complete <- cbind(outcome_variable, covariates)
  data_complete$V3 <- as.factor(data_complete$V3)
  
  data_w_missing <- suppressWarnings(ampute(data_complete, prop = prop, mech = "MAR", patterns = c(0, 1, 1, 1))$amp)
  
  data_w_missing$V3 <- as.factor(ifelse(data_w_missing$V3 == 1, 0, 1))
  
  # "outcome_variable" is an outcome variable with 30% MAR. Covariates are fully observed. 
  
  # The analysis model is outcome_variable ~ V1 + V2 + V3 + V2*V3 + epsilon 
  # We are interested in estimating var(beta*V2)
  
  return(data_w_missing)
}
```

## Creating dataframe of inputs

```{r, eval = FALSE}
set.seed(971423)
N = 1e3 
# 1e3 iterations of 4x4 unique conditions. 

p_mis_vec <- c(rep(0.10, N), rep(0.30, N), rep(0.50, N), rep(0.70, N))

sample_size_vec <- c(rep(1e2, N/4), rep(1e3, N/4), rep(1e4, N/4), rep(1e5, N/4))

seed_vec <- seq.int(from = 1, to = N*4)

sample_size_vec_repeated <- rep.int(sample_size_vec, 4)

param_df <- data.frame(sample_size = sample_size_vec_repeated, prop = p_mis_vec, seed = seed_vec)

plan(multisession, workers = parallel::detectCores()-1)

sim_dfs <- future_pmap(param_df, data_generator, .progress = TRUE)

```

### Small dataset for general use 
```{r}
df_w_mis <- data_generator(1e2, 213, 0.20)

subsamples <- vector("list", nrow(df_w_mis))
for(i in 1:nrow(df_w_mis)){
  subsamples[[i]] <- df_w_mis[-i,]}

contains_na <- map_lgl(subsamples, ~any(is.na(.x)))

for(i in 1:length(subsamples)){
  if(contains_na[[i]] == TRUE){
    subsamples[[i]] <- mice(subsamples[[i]], m = 5, method = "pmm")
  } else{
    subsamples[[i]] <- subsamples[[i]]
  }
}

# Estimated vars, need to add test in case there is non-mice object 
analysis_vector<- vector("numeric", nrow(df_w_mis))
for(i in 1:length(subsamples)){
  sample_size <- nrow(complete(subsamples[[i]],1))
  analysis_vector[[i]] <- subsamples[[i]] %>%
    mice::complete("all") %>%
    map(lm, formula = outcome_variable ~ V1 + V2 + V3 + V2:V3) %>%
    pool() %>%
    broom::tidy() %>%
    dplyr::filter(term == "V2") %>%
    dplyr::select("std.error") %>%
    dplyr::mutate(variance = {std.error*{sample_size^{1/2}}}^2) %>%
    dplyr::select("variance") %>%
    unlist()
}

# True var 
true_var <- lm(outcome_variable ~ V1 + V2 + V3 + V2:V3, data = df_w_mis) %>%
  summary() %>%
  tidy() %>%
  dplyr::filter(term == "V2") %>%
  dplyr::select("std.error") %>%
  dplyr::mutate(variance = {std.error*{nrow(df_w_mis)^{1/2}}}^2) %>%
  dplyr::select("variance") %>%
  unlist()

UB <- round(quantile(analysis_vector, probs = 1-0.05),2)
LB <- round(quantile(analysis_vector, probs = 0.05),2)

print(data.frame(UB,
                 LB,
                 "point_estimate" =  mean(analysis_vector),
                 "true_variance" = true_var))
```

# Converting small example above to function for MC 
```{r}
jackknife_v1 <- function(df_w_mis, seed){
  set.seed(seed)
  subsamples <- vector("list", nrow(df_w_mis))
for(i in 1:nrow(df_w_mis)){
  subsamples[[i]] <- df_w_mis[-i,]}

contains_na <- map_lgl(subsamples, ~any(is.na(.x)))

for(i in 1:length(subsamples)){
  if(contains_na[[i]] == TRUE){
    subsamples[[i]] <- mice(subsamples[[i]], m = 5, method = "pmm", print=FALSE)
  } else{
    subsamples[[i]] <- subsamples[[i]]
  }
}

# Estimated vars 
analysis_vector<- vector("numeric", nrow(df_w_mis))
for(i in 1:length(subsamples)){
  sample_size <- nrow(complete(subsamples[[i]],1))
  analysis_vector[[i]] <- subsamples[[i]] %>%
    mice::complete("all") %>%
    map(lm, formula = outcome_variable ~ V1 + V2 + V3 + V2:V3) %>%
    pool() %>%
    broom::tidy() %>%
    dplyr::filter(term == "V2") %>%
    dplyr::select("std.error") %>%
    dplyr::mutate(variance = {std.error*{sample_size^{1/2}}}^2) %>%
    dplyr::select("variance") %>%
    unlist()
}

UB <- round(quantile(analysis_vector, probs = 1-0.05),2)
LB <- round(quantile(analysis_vector, probs = 0.05),2)

return(data.frame(UB,
                 LB,
                 "point_estimate" =  mean(analysis_vector)))
}
library(parallel)
cl <- makeCluster(4)
mc_res <- mclapply(mc.cores = 4, c(1:100), function(x) jackknife_v1(df_w_mis, seed = x))

mc_res_df <- do.call(rbind, mc_res) 

rownames(mc_res_df) <- NULL

saveRDS(mc_res_df, "small_mc_res")

df <- cbind(mc_res_df, true_var)

round((sum(df$true_var < df$UB & df$true_var > df$LB) / nrow(df))*100,2)

ggplot(data = df,
           aes(point_estimate - true_var)) + 
      geom_density(aes(y = ..density..)) + 
      theme(axis.title.y = element_blank(), 
            panel.spacing=unit(1.5,"lines")) + 
      theme_bw() + 
      theme(axis.title.y = element_blank(), 
            panel.spacing=unit(1.5,"lines"), 
            strip.text = element_text(
              size = 9)) + 
      xlab("Bias of variance estimator") + 
      ggpubr::stat_overlay_normal_density(color = "red", linetype = "dashed")

ggplot(df, aes(x = c(1:nrow(df)), y = point_estimate)) + 
      geom_point(aes(color = "red")) + 
      geom_errorbar(aes(ymin = LB, ymax = UB, alpha = 1)) + 
      coord_flip() + 
      theme_bw() + 
      labs(
        x = latex2exp::TeX("$i^{th} dataset"), 
        y = latex2exp::TeX("$\\widehat{\\sigma^2}")
      ) + 
      theme(legend.position="none") + 
      geom_hline(yintercept = true_var)
```

